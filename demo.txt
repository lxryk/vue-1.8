<div id="a1"> <h1>global</h1> <p>Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p> <p>silent</p> <ul> <li> <p><strong>类型</strong>：boolean</p> </li> <li> <p><strong>默认值</strong>：false</p> </li> </ul> <p>用法：</p> <p>Vue.config.silent = true<br /> 取消 Vue 所有的日志与警告。</p> </div> <div id="a2"> <h1>devtools</h1> <ul> <li> <p><strong>类型</strong>：boolean</p> </li> <li> <p><strong>默认值</strong>：true (生产版为 false)</p> </li> </ul> <p>用法：</p> <pre><code class="lang-">// 务必在加载 Vue 之后，立即同步设置以下内容 Vue.config.devtools = true </code></pre> <p>配置是否允许 vue-devtools 检查代码。开发版本默认为 true，生产版本默认为 false。生产版本设为 true 可以启用检查。</p> </div> <div id="a3"> <h1>errorHandler</h1> <ul> <li> <p><strong>类型</strong>：Function</p> </li> <li> <p><strong>默认值</strong>：undefined</p> </li> </ul> <p>用法：</p> <pre><code class="lang-">Vue.config.errorHandler = function (err, vm, info) { // handle error // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 // 只在 2.2.0+ 可用 } </code></pre> <p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p> </div> <div id="a4"> <h1>API</h1> <p>asdfghjkl;'mnbvcxz<br /> wertyuiokjhgfd<br /> vcxzzdfghjkl</p> </div> <div id="a5"> <h1>component</h1> <ul> <li><strong>参数</strong>：</li> </ul> <p>{string} id<br /> {Function | Object} [definition]</p> <ul> <li><strong>用法</strong>：</li> </ul> <pre><code class="lang-"> 注册或获取全局组件。注册还会自动使用给定的id设置组件的名称 // 注册组件，传入一个扩展过的构造器 Vue.component('my-component', Vue.extend({ /* ... */ })) // 注册组件，传入一个选项对象 (自动调用 Vue.extend) Vue.component('my-component', { /* ... */ }) // 获取注册的组件 (始终返回构造器) var MyComponent = Vue.component('my-component') </code></pre> </div> <div id="a6"> <h1>filter</h1> <ul> <li><strong>参数</strong>：</li> </ul> <p>{string} id<br /> {Function} [definition]</p> <ul> <li><strong>用法</strong>：</li> </ul> <p>注册或获取全局过滤器。</p> <pre><code class="lang-">// 注册 Vue.filter('my-filter', function (value) { // 返回处理后的值 }) // getter，返回已注册的过滤器 var myFilter = Vue.filter('my-filter') </code></pre> </div> <div id="a7"> <h1>option</h1> <p>asdfghjkl;'mnbvcxz<br /> wertyuiokjhgfd<br /> vcxzzdfghjkl</p> </div> <div id="a8"> <h1>data</h1> <ul> <li> <p><strong>类型</strong>：Object | Function</p> </li> <li> <p><strong>限制</strong>：组件的定义只接受 function。</p> </li> <li> <p><strong>详细</strong>：</p> </li> </ul> <p>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p> <p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p> <p>实例创建之后，可以通过 vm.data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.data.a。</p> <p>以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。</p> <p>当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。</p> <p>如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(…)) 得到深拷贝的原始数据对象。</p> <ul> <li><strong>示例</strong>：</li> </ul> <pre><code class="lang-"> var data = { a: 1 } // 直接创建一个实例 var vm = new Vue({ data: data }) vm.a // =&gt; 1 vm.$data === data // =&gt; true // Vue.extend() 中 data 必须是函数 var Component = Vue.extend({ data: function () { return { a: 1 } } }) 注意，不应该对 data </code></pre> </div> <div id="a9"> <h1>methods</h1> <ul> <li> <p><strong>类型</strong>：{ [key: string]: Function }</p> </li> <li> <p><strong>详细</strong>：</p> </li> </ul> <p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p> <p>注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () =&gt; this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。</p> <ul> <li><strong>示例</strong>：</li> </ul> <pre><code class="lang-">var vm = new Vue({ data: { a: 1 }, methods: { plus: function () { this.a++ } } }) vm.plus() vm.a // 2 </code></pre> </div>